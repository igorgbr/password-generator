"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
var process_1 = require("process");
var options_1 = require("./options");
var worker_sync_function_1 = require("./worker-sync-function");
/**
 * Register the css files handle for node.js
 * @public
 * @param extensions - list of extensions, by default '.css', '.scss', '.sass', '.less', '.stylus'
 * @param timeout - the timeout of processing
 * @param bufferSize - the data buffer size
 */
function register(extensions, timeout, bufferSize) {
    var _a;
    if (extensions === void 0) { extensions = ((_a = process_1.env.POSTCSS_NODE_EXT) === null || _a === void 0 ? void 0 : _a.split(',')) || options_1.defaultPostCssNodeExtensions; }
    if (timeout === void 0) { timeout = process_1.env.POSTCSS_NODE_TIMEOUT ? parseInt(process_1.env.POSTCSS_NODE_TIMEOUT) : options_1.defaultResponseTimeout; }
    if (bufferSize === void 0) { bufferSize = process_1.env.POSTCSS_NODE_BUFFER_SIZE ? parseInt(process_1.env.POSTCSS_NODE_BUFFER_SIZE) : options_1.defaultBufferSize; }
    var renderCssFile;
    var jsHandle = require.extensions['.js'];
    var cssHandle = (function (module, filename) {
        var orgCompile = module._compile;
        module._compile = function (code, fileName) {
            if (!renderCssFile) {
                renderCssFile = worker_sync_function_1.workerSyncFunction(__dirname + '/worker.js', timeout, bufferSize);
            }
            var _a = renderCssFile({ code: code, filename: filename }), css = _a.css, ex = _a.ex;
            /* istanbul ignore else */
            if (css) {
                return orgCompile.call(this, css, fileName);
            }
            else {
                throw ex;
            }
        };
        return jsHandle(module, filename);
    });
    extensions.forEach(function (ext) { return require.extensions[ext] = cssHandle; });
}
exports.register = register;
//# sourceMappingURL=register.js.map